package oneofhelper

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// TestExhaustiveGoldenFiles performs exhaustive byte-for-byte comparison
// between generated output and golden files
func TestExhaustiveGoldenFiles(t *testing.T) {
	// Build the plugin binary for testing
	pluginPath := "./protoc-gen-go-oneof-helper-golden-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	//defer os.Remove(pluginPath)

	testCases := []struct {
		name       string
		protoFile  string
		goldenFile string
	}{
		{
			name:       "simple_oneof",
			protoFile:  "testdata/proto/simple_oneof.proto",
			goldenFile: "testdata/golden/simple_oneof_helpers.pb.go",
		},
		{
			name:       "complex_types",
			protoFile:  "testdata/proto/complex_types.proto",
			goldenFile: "testdata/golden/complex_types_helpers.pb.go",
		},
		{
			name:       "nested_messages",
			protoFile:  "testdata/proto/nested_messages.proto",
			goldenFile: "testdata/golden/nested_messages_helpers.pb.go",
		},
		{
			name:       "no_oneof",
			protoFile:  "testdata/proto/no_oneof.proto",
			goldenFile: "testdata/golden/no_oneof_helpers.pb.go",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate fresh output using protoc
			tempDir, err := ioutil.TempDir("", "exhaustive-golden-test-*")
			if err != nil {
				t.Fatalf("Failed to create temp dir: %v", err)
			}
			defer os.RemoveAll(tempDir)

			// Run protoc to generate new output
			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
				"--go-helpers_out="+tempDir,
				"--proto_path=testdata/proto",
				tc.protoFile,
			)

			var stdout, stderr bytes.Buffer
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr

			if err := cmd.Run(); err != nil {
				t.Fatalf("protoc failed for %s: %v\nStdout: %s\nStderr: %s",
					tc.name, err, stdout.String(), stderr.String())
			}

			// Find the generated file
			baseName := strings.TrimSuffix(filepath.Base(tc.protoFile), ".proto")
			generatedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
				"cmd", "protoc-gen-go-oneof-helper", "testdata", baseName+"_helpers.pb.go")

			// Read generated content
			generatedContent, err := ioutil.ReadFile(generatedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file: %v", err)
			}

			// Read golden file content
			goldenContent, err := ioutil.ReadFile(tc.goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file %s: %v", tc.goldenFile, err)
			}

			// Perform exhaustive byte-for-byte comparison
			if !bytes.Equal(generatedContent, goldenContent) {
				// Detailed diff analysis
				generated := string(generatedContent)
				golden := string(goldenContent)

				t.Errorf("Generated output does not match golden file for %s", tc.name)
				t.Errorf("Generated file size: %d bytes", len(generatedContent))
				t.Errorf("Golden file size: %d bytes", len(goldenContent))

				// Find first difference
				minLen := len(generated)
				if len(golden) < minLen {
					minLen = len(golden)
				}

				firstDiff := -1
				for i := 0; i < minLen; i++ {
					if generated[i] != golden[i] {
						firstDiff = i
						break
					}
				}

				if firstDiff >= 0 {
					t.Errorf("First difference at byte position %d", firstDiff)
					t.Errorf("Generated byte: %d (%c)", generated[firstDiff], generated[firstDiff])
					t.Errorf("Golden byte: %d (%c)", golden[firstDiff], golden[firstDiff])
				}

				// Line-by-line diff for readability
				generatedLines := strings.Split(generated, "\n")
				goldenLines := strings.Split(golden, "\n")

				maxLines := len(generatedLines)
				if len(goldenLines) > maxLines {
					maxLines = len(goldenLines)
				}

				diffCount := 0
				for i := 0; i < maxLines && diffCount < 10; i++ { // Limit to first 10 differences
					var generatedLine, goldenLine string
					if i < len(generatedLines) {
						generatedLine = generatedLines[i]
					}
					if i < len(goldenLines) {
						goldenLine = goldenLines[i]
					}

					if generatedLine != goldenLine {
						t.Errorf("Line %d differs:", i+1)
						t.Errorf("  Generated: %q", generatedLine)
						t.Errorf("  Golden:    %q", goldenLine)
						diffCount++
					}
				}

				if diffCount >= 10 {
					t.Errorf("... (showing first 10 differences only)")
				}

				// Option to update golden files
				if os.Getenv("UPDATE_GOLDEN") == "1" {
					if err := ioutil.WriteFile(tc.goldenFile, generatedContent, 0644); err != nil {
						t.Logf("Failed to update golden file: %v", err)
					} else {
						t.Logf("Updated golden file: %s", tc.goldenFile)
					}
				} else {
					t.Log("To update golden files, run: UPDATE_GOLDEN=1 go test -run TestExhaustiveGoldenFiles")
				}

				// Write generated content to a temporary file for manual inspection
				tempGenFile := tc.goldenFile + ".generated"
				if err := ioutil.WriteFile(tempGenFile, generatedContent, 0644); err == nil {
					t.Logf("Generated content written to: %s", tempGenFile)
					t.Logf("Compare with: diff %s %s", tc.goldenFile, tempGenFile)
				}
			} else {
				t.Logf("âœ“ Perfect match for %s (%d bytes)", tc.name, len(generatedContent))
			}
		})
	}
}

// TestExhaustiveRegression tests that any change to the implementation
// is detected by comparing against multiple golden files
func TestExhaustiveRegression(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping exhaustive regression test in short mode")
	}

	// Build the plugin
	pluginPath := "./protoc-gen-go-oneof-helper-regression-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	// Test all proto files in testdata/proto
	protoFiles, err := filepath.Glob("testdata/proto/*.proto")
	if err != nil {
		t.Fatalf("Failed to find proto files: %v", err)
	}

	if len(protoFiles) == 0 {
		t.Fatal("No proto files found in testdata/proto")
	}

	for _, protoFile := range protoFiles {
		baseName := strings.TrimSuffix(filepath.Base(protoFile), ".proto")
		goldenFile := fmt.Sprintf("testdata/golden/%s_helpers.pb.go", baseName)

		// Check if golden file exists
		if _, err := os.Stat(goldenFile); os.IsNotExist(err) {
			t.Errorf("Golden file missing for %s: %s", protoFile, goldenFile)
			continue
		}

		t.Run(baseName, func(t *testing.T) {
			// Generate output
			tempDir, err := ioutil.TempDir("", "regression-test-*")
			if err != nil {
				t.Fatalf("Failed to create temp dir: %v", err)
			}
			defer os.RemoveAll(tempDir)

			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
				"--go-helpers_out="+tempDir,
				"--proto_path=testdata/proto",
				protoFile,
			)

			if err := cmd.Run(); err != nil {
				t.Fatalf("protoc failed for %s: %v", protoFile, err)
			}

			// Find generated file
			generatedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
				"cmd", "protoc-gen-go-oneof-helper", "testdata", baseName+"_helpers.pb.go")

			// Compare with golden file
			generatedContent, err := ioutil.ReadFile(generatedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file: %v", err)
			}

			goldenContent, err := ioutil.ReadFile(goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file: %v", err)
			}

			if !bytes.Equal(generatedContent, goldenContent) {
				t.Errorf("Regression detected in %s", protoFile)
				t.Errorf("Generated output differs from golden file")

				// Show a summary of the difference
				genLines := strings.Split(string(generatedContent), "\n")
				goldenLines := strings.Split(string(goldenContent), "\n")
				t.Errorf("Generated: %d lines, Golden: %d lines", len(genLines), len(goldenLines))
			}
		})
	}
}

// TestGoldenFileValidity ensures all golden files are valid Go code
func TestGoldenFileValidity(t *testing.T) {
	goldenFiles, err := filepath.Glob("testdata/golden/*.go")
	if err != nil {
		t.Fatalf("Failed to find golden files: %v", err)
	}

	for _, goldenFile := range goldenFiles {
		t.Run(filepath.Base(goldenFile), func(t *testing.T) {
			// Check if file is syntactically valid Go
			cmd := exec.Command("go", "fmt", goldenFile)
			if err := cmd.Run(); err != nil {
				t.Errorf("Golden file %s is not valid Go code: %v", goldenFile, err)
			}

			// Read content and perform basic validation
			content, err := ioutil.ReadFile(goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file: %v", err)
			}

			contentStr := string(content)

			// Must have generation comment
			if !strings.Contains(contentStr, "Code generated by protoc-gen-go-helpers. DO NOT EDIT.") {
				t.Error("Golden file missing generation comment")
			}

			// Must have package declaration
			if !strings.Contains(contentStr, "package testdata") {
				t.Error("Golden file missing or incorrect package declaration")
			}

			// Should not have syntax errors (basic check)
			if strings.Contains(contentStr, "func New") {
				// Files with functions should have proper Go syntax
				lines := strings.Split(contentStr, "\n")
				braceCount := 0
				for i, line := range lines {
					braceCount += strings.Count(line, "{")
					braceCount -= strings.Count(line, "}")
					if braceCount < 0 {
						t.Errorf("Unmatched closing brace at line %d: %s", i+1, line)
						break
					}
				}
				if braceCount != 0 {
					t.Errorf("Unmatched braces in file (count: %d)", braceCount)
				}
			}
		})
	}
}

// BenchmarkExhaustiveComparison benchmarks the golden file comparison process
func BenchmarkExhaustiveComparison(b *testing.B) {
	// Read a sample golden file
	goldenFile := "testdata/golden/simple_oneof_helpers.pb.go"
	goldenContent, err := ioutil.ReadFile(goldenFile)
	if err != nil {
		b.Fatalf("Failed to read golden file: %v", err)
	}

	// Create identical content for comparison
	generatedContent := make([]byte, len(goldenContent))
	copy(generatedContent, goldenContent)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = bytes.Equal(generatedContent, goldenContent)
	}
}
