package oneofhelper

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestFileBasedIntegration(t *testing.T) {
	// Build the plugin binary for testing
	pluginPath := "./protoc-gen-go-oneof-helper-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	testCases := []struct {
		name              string
		protoFile         string
		expectEmptyOutput bool
	}{
		{
			name:              "simple oneof",
			protoFile:         "simple_oneof.proto",
			expectEmptyOutput: false,
		},
		{
			name:              "complex types",
			protoFile:         "complex_types.proto",
			expectEmptyOutput: false,
		},
		{
			name:              "nested messages",
			protoFile:         "nested_messages.proto",
			expectEmptyOutput: false,
		},
		{
			name:              "no oneof",
			protoFile:         "no_oneof.proto",
			expectEmptyOutput: true, // Should only generate header
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create temporary output directory
			tempDir, err := ioutil.TempDir("", "protoc-gen-go-oneof-helper-test-*")
			if err != nil {
				t.Fatalf("Failed to create temp dir: %v", err)
			}
			defer os.RemoveAll(tempDir)

			// Run protoc with our plugin
			protoPath := filepath.Join("testdata", "proto", tc.protoFile)
			cmd := exec.Command("protoc",
				"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
				"--go-helpers_out="+tempDir,
				"--proto_path=testdata/proto",
				protoPath,
			)

			var stdout, stderr bytes.Buffer
			cmd.Stdout = &stdout
			cmd.Stderr = &stderr

			if err := cmd.Run(); err != nil {
				t.Fatalf("protoc failed: %v\nStdout: %s\nStderr: %s",
					err, stdout.String(), stderr.String())
			}

			// Find the generated file
			baseName := strings.TrimSuffix(tc.protoFile, ".proto")
			expectedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
				"cmd", "protoc-gen-go-oneof-helper", "testdata", baseName+"_helpers.pb.go")

			// Check if file was generated
			if _, err := os.Stat(expectedFile); err != nil {
				t.Fatalf("Generated file not found: %s", expectedFile)
			}

			// Read the generated content
			content, err := ioutil.ReadFile(expectedFile)
			if err != nil {
				t.Fatalf("Failed to read generated file: %v", err)
			}

			contentStr := string(content)

			// Basic structure checks
			if !strings.Contains(contentStr, "Code generated by protoc-gen-go-helpers") {
				t.Error("Generated file should contain generation notice")
			}

			if !strings.Contains(contentStr, "package testdata") {
				t.Error("Generated file should contain correct package declaration")
			}

			// Check if output matches expectation
			if tc.expectEmptyOutput {
				// Should only have header comments and package declaration
				lines := strings.Split(strings.TrimSpace(contentStr), "\n")
				if len(lines) > 4 {
					t.Errorf("Expected minimal output for %s, but got %d lines", tc.name, len(lines))
				}
			} else {
				// Should have at least one helper function
				if !strings.Contains(contentStr, "func New") {
					t.Errorf("Expected helper functions for %s, but found none", tc.name)
				}
			}
		})
	}
}

// TestFileConsistency ensures that running the plugin multiple times produces identical output
func TestFileConsistency(t *testing.T) {
	// Build the plugin binary
	pluginPath := "./protoc-gen-go-oneof-helper-test"
	buildCmd := exec.Command("go", "build", "-o", pluginPath, "../../cmd/protoc-gen-go-oneof-helper")
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build plugin: %v", err)
	}
	defer os.Remove(pluginPath)

	protoFile := "testdata/proto/simple_oneof.proto"

	// Generate output twice
	var outputs []string
	for i := 0; i < 2; i++ {
		tempDir, err := ioutil.TempDir("", "protoc-consistency-test-*")
		if err != nil {
			t.Fatalf("Failed to create temp dir: %v", err)
		}
		defer os.RemoveAll(tempDir)

		cmd := exec.Command("protoc",
			"--plugin=protoc-gen-go-oneof-helper="+pluginPath,
			"--go-helpers_out="+tempDir,
			"--proto_path=testdata/proto",
			protoFile,
		)

		if err := cmd.Run(); err != nil {
			t.Fatalf("protoc failed on run %d: %v", i+1, err)
		}

		// Find and read the generated file
		generatedFile := filepath.Join(tempDir, "github.com", "anghami", "anghamak-go",
			"cmd", "protoc-gen-go-oneof-helper", "testdata", "simple_oneof_helpers.pb.go")

		content, err := ioutil.ReadFile(generatedFile)
		if err != nil {
			t.Fatalf("Failed to read generated file on run %d: %v", i+1, err)
		}

		outputs = append(outputs, string(content))
	}

	// Compare the outputs
	if outputs[0] != outputs[1] {
		t.Error("Plugin output is not consistent between runs")
		t.Logf("First run output length: %d", len(outputs[0]))
		t.Logf("Second run output length: %d", len(outputs[1]))
	}
}
